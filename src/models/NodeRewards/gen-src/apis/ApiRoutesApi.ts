/* tslint:disable */
/* eslint-disable */
/**
 * Symbol Node Rewards API
 * The API is the rest gateway to the symbol rewards controller.
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ErrorDTO,
    ErrorDTOFromJSON,
    ErrorDTOToJSON,
    HealthDTO,
    HealthDTOFromJSON,
    HealthDTOToJSON,
    NodeInfoDTO,
    NodeInfoDTOFromJSON,
    NodeInfoDTOToJSON,
    NodeInfoPageDTO,
    NodeInfoPageDTOFromJSON,
    NodeInfoPageDTOToJSON,
    OrderDTO,
    OrderDTOFromJSON,
    OrderDTOToJSON,
    PayoutPageDTO,
    PayoutPageDTOFromJSON,
    PayoutPageDTOToJSON,
    TestResultDTO,
    TestResultDTOFromJSON,
    TestResultDTOToJSON,
    TestResultInfoDTO,
    TestResultInfoDTOFromJSON,
    TestResultInfoDTOToJSON,
} from '../models';

export interface FindNodeByIdRequest {
    id: string;
}

export interface FindNodeByMainPublicKeyRequest {
    mainPublicKey: string;
}

export interface FindNodeByNodePublicKeyRequest {
    nodePublicKey: string;
}

export interface GetTestResultInfoRequest {
    nodeId: string;
    round: number;
}

export interface GetTestResultsRequest {
    nodeId: string;
    fromRound?: number;
    count?: number;
}

export interface SearchNodeInfosRequest {
    pageNumber?: number;
    order?: OrderDTO;
    pageSize?: number;
}

export interface SearchPayoutsRequest {
    pageNumber?: number;
    order?: OrderDTO;
    pageSize?: number;
    nodeId?: string;
}

/**
 * ApiRoutesApi - interface
 * 
 * @export
 * @interface ApiRoutesApiInterface
 */
export interface ApiRoutesApiInterface {
    /**
     * 
     * @summary Returns a single node with given id
     * @param {string} id Node ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiRoutesApiInterface
     */
    findNodeByIdRaw(requestParameters: FindNodeByIdRequest): Promise<runtime.ApiResponse<NodeInfoDTO>>;

    /**
     * Returns a single node with given id
     */
    findNodeById(id: string): Promise<NodeInfoDTO>;

    /**
     * 
     * @summary Returns a single node with given mainPublicKey
     * @param {string} mainPublicKey Node linked account public key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiRoutesApiInterface
     */
    findNodeByMainPublicKeyRaw(requestParameters: FindNodeByMainPublicKeyRequest): Promise<runtime.ApiResponse<NodeInfoDTO>>;

    /**
     * Returns a single node with given mainPublicKey
     */
    findNodeByMainPublicKey(mainPublicKey: string): Promise<NodeInfoDTO>;

    /**
     * 
     * @summary Returns a single node with given nodePublicKey
     * @param {string} nodePublicKey Node linked account public key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiRoutesApiInterface
     */
    findNodeByNodePublicKeyRaw(requestParameters: FindNodeByNodePublicKeyRequest): Promise<runtime.ApiResponse<NodeInfoDTO>>;

    /**
     * Returns a single node with given nodePublicKey
     */
    findNodeByNodePublicKey(nodePublicKey: string): Promise<NodeInfoDTO>;

    /**
     * 
     * @summary Returns the Open Api specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiRoutesApiInterface
     */
    getSpecRaw(): Promise<runtime.ApiResponse<void>>;

    /**
     * Returns the Open Api specification
     */
    getSpec(): Promise<void>;

    /**
     * 
     * @summary Returns a test rusult info by given nodeId and round
     * @param {string} nodeId Node ID
     * @param {number} round The round number of the test result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiRoutesApiInterface
     */
    getTestResultInfoRaw(requestParameters: GetTestResultInfoRequest): Promise<runtime.ApiResponse<TestResultInfoDTO>>;

    /**
     * Returns a test rusult info by given nodeId and round
     */
    getTestResultInfo(nodeId: string, round: number): Promise<TestResultInfoDTO>;

    /**
     * 
     * @summary Returns a test rusult list by given nodeId
     * @param {string} nodeId Node ID
     * @param {number} [fromRound] Only results with round number equal and less than this one are returned
     * @param {number} [count] The number of records
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiRoutesApiInterface
     */
    getTestResultsRaw(requestParameters: GetTestResultsRequest): Promise<runtime.ApiResponse<Array<TestResultDTO>>>;

    /**
     * Returns a test rusult list by given nodeId
     */
    getTestResults(nodeId: string, fromRound?: number, count?: number): Promise<Array<TestResultDTO>>;

    /**
     * 
     * @summary Returns if the rest api is healthy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiRoutesApiInterface
     */
    healthRaw(): Promise<runtime.ApiResponse<HealthDTO>>;

    /**
     * Returns if the rest api is healthy
     */
    health(): Promise<HealthDTO>;

    /**
     * 
     * @summary Returns a page of node information.
     * @param {number} [pageNumber] Filter by page number.
     * @param {OrderDTO} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
     * @param {number} [pageSize] Select the number of entries to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiRoutesApiInterface
     */
    searchNodeInfosRaw(requestParameters: SearchNodeInfosRequest): Promise<runtime.ApiResponse<NodeInfoPageDTO>>;

    /**
     * Returns a page of node information.
     */
    searchNodeInfos(pageNumber?: number, order?: OrderDTO, pageSize?: number): Promise<NodeInfoPageDTO>;

    /**
     * 
     * @summary Returns a page of node payout.
     * @param {number} [pageNumber] Filter by page number.
     * @param {OrderDTO} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
     * @param {number} [pageSize] Select the number of entries to return.
     * @param {string} [nodeId] Node ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiRoutesApiInterface
     */
    searchPayoutsRaw(requestParameters: SearchPayoutsRequest): Promise<runtime.ApiResponse<PayoutPageDTO>>;

    /**
     * Returns a page of node payout.
     */
    searchPayouts(pageNumber?: number, order?: OrderDTO, pageSize?: number, nodeId?: string): Promise<PayoutPageDTO>;

}

/**
 * 
 */
export class ApiRoutesApi extends runtime.BaseAPI implements ApiRoutesApiInterface {

    /**
     * Returns a single node with given id
     */
    async findNodeByIdRaw(requestParameters: FindNodeByIdRequest): Promise<runtime.ApiResponse<NodeInfoDTO>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling findNodeById.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/nodes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => NodeInfoDTOFromJSON(jsonValue));
    }

    /**
     * Returns a single node with given id
     */
    async findNodeById(id: string): Promise<NodeInfoDTO> {
        const response = await this.findNodeByIdRaw({ id: id });
        return await response.value();
    }

    /**
     * Returns a single node with given mainPublicKey
     */
    async findNodeByMainPublicKeyRaw(requestParameters: FindNodeByMainPublicKeyRequest): Promise<runtime.ApiResponse<NodeInfoDTO>> {
        if (requestParameters.mainPublicKey === null || requestParameters.mainPublicKey === undefined) {
            throw new runtime.RequiredError('mainPublicKey','Required parameter requestParameters.mainPublicKey was null or undefined when calling findNodeByMainPublicKey.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/nodes/mainPublicKey/{mainPublicKey}`.replace(`{${"mainPublicKey"}}`, encodeURIComponent(String(requestParameters.mainPublicKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => NodeInfoDTOFromJSON(jsonValue));
    }

    /**
     * Returns a single node with given mainPublicKey
     */
    async findNodeByMainPublicKey(mainPublicKey: string): Promise<NodeInfoDTO> {
        const response = await this.findNodeByMainPublicKeyRaw({ mainPublicKey: mainPublicKey });
        return await response.value();
    }

    /**
     * Returns a single node with given nodePublicKey
     */
    async findNodeByNodePublicKeyRaw(requestParameters: FindNodeByNodePublicKeyRequest): Promise<runtime.ApiResponse<NodeInfoDTO>> {
        if (requestParameters.nodePublicKey === null || requestParameters.nodePublicKey === undefined) {
            throw new runtime.RequiredError('nodePublicKey','Required parameter requestParameters.nodePublicKey was null or undefined when calling findNodeByNodePublicKey.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/nodes/nodePublicKey/{nodePublicKey}`.replace(`{${"nodePublicKey"}}`, encodeURIComponent(String(requestParameters.nodePublicKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => NodeInfoDTOFromJSON(jsonValue));
    }

    /**
     * Returns a single node with given nodePublicKey
     */
    async findNodeByNodePublicKey(nodePublicKey: string): Promise<NodeInfoDTO> {
        const response = await this.findNodeByNodePublicKeyRaw({ nodePublicKey: nodePublicKey });
        return await response.value();
    }

    /**
     * Returns the Open Api specification
     */
    async getSpecRaw(): Promise<runtime.ApiResponse<void>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/spec`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns the Open Api specification
     */
    async getSpec(): Promise<void> {
        await this.getSpecRaw();
    }

    /**
     * Returns a test rusult info by given nodeId and round
     */
    async getTestResultInfoRaw(requestParameters: GetTestResultInfoRequest): Promise<runtime.ApiResponse<TestResultInfoDTO>> {
        if (requestParameters.nodeId === null || requestParameters.nodeId === undefined) {
            throw new runtime.RequiredError('nodeId','Required parameter requestParameters.nodeId was null or undefined when calling getTestResultInfo.');
        }

        if (requestParameters.round === null || requestParameters.round === undefined) {
            throw new runtime.RequiredError('round','Required parameter requestParameters.round was null or undefined when calling getTestResultInfo.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/testResultInfo/nodeId/{nodeId}/round/{round}`.replace(`{${"nodeId"}}`, encodeURIComponent(String(requestParameters.nodeId))).replace(`{${"round"}}`, encodeURIComponent(String(requestParameters.round))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TestResultInfoDTOFromJSON(jsonValue));
    }

    /**
     * Returns a test rusult info by given nodeId and round
     */
    async getTestResultInfo(nodeId: string, round: number): Promise<TestResultInfoDTO> {
        const response = await this.getTestResultInfoRaw({ nodeId: nodeId, round: round });
        return await response.value();
    }

    /**
     * Returns a test rusult list by given nodeId
     */
    async getTestResultsRaw(requestParameters: GetTestResultsRequest): Promise<runtime.ApiResponse<Array<TestResultDTO>>> {
        if (requestParameters.nodeId === null || requestParameters.nodeId === undefined) {
            throw new runtime.RequiredError('nodeId','Required parameter requestParameters.nodeId was null or undefined when calling getTestResults.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.fromRound !== undefined) {
            queryParameters['fromRound'] = requestParameters.fromRound;
        }

        if (requestParameters.count !== undefined) {
            queryParameters['count'] = requestParameters.count;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/testResults/nodeId/{nodeId}`.replace(`{${"nodeId"}}`, encodeURIComponent(String(requestParameters.nodeId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TestResultDTOFromJSON));
    }

    /**
     * Returns a test rusult list by given nodeId
     */
    async getTestResults(nodeId: string, fromRound?: number, count?: number): Promise<Array<TestResultDTO>> {
        const response = await this.getTestResultsRaw({ nodeId: nodeId, fromRound: fromRound, count: count });
        return await response.value();
    }

    /**
     * Returns if the rest api is healthy
     */
    async healthRaw(): Promise<runtime.ApiResponse<HealthDTO>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/health`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => HealthDTOFromJSON(jsonValue));
    }

    /**
     * Returns if the rest api is healthy
     */
    async health(): Promise<HealthDTO> {
        const response = await this.healthRaw();
        return await response.value();
    }

    /**
     * Returns a page of node information.
     */
    async searchNodeInfosRaw(requestParameters: SearchNodeInfosRequest): Promise<runtime.ApiResponse<NodeInfoPageDTO>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['pageNumber'] = requestParameters.pageNumber;
        }

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/nodes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => NodeInfoPageDTOFromJSON(jsonValue));
    }

    /**
     * Returns a page of node information.
     */
    async searchNodeInfos(pageNumber?: number, order?: OrderDTO, pageSize?: number): Promise<NodeInfoPageDTO> {
        const response = await this.searchNodeInfosRaw({ pageNumber: pageNumber, order: order, pageSize: pageSize });
        return await response.value();
    }

    /**
     * Returns a page of node payout.
     */
    async searchPayoutsRaw(requestParameters: SearchPayoutsRequest): Promise<runtime.ApiResponse<PayoutPageDTO>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['pageNumber'] = requestParameters.pageNumber;
        }

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        if (requestParameters.nodeId !== undefined) {
            queryParameters['nodeId'] = requestParameters.nodeId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/payouts`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PayoutPageDTOFromJSON(jsonValue));
    }

    /**
     * Returns a page of node payout.
     */
    async searchPayouts(pageNumber?: number, order?: OrderDTO, pageSize?: number, nodeId?: string): Promise<PayoutPageDTO> {
        const response = await this.searchPayoutsRaw({ pageNumber: pageNumber, order: order, pageSize: pageSize, nodeId: nodeId });
        return await response.value();
    }

}
